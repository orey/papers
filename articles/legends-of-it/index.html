<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Olivier Rey">
        <link rel="canonical" href="https://orey.github.io/papers/articles/legends-of-it/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Legends of IT - Papers</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-BZMZKWJP2V"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-BZMZKWJP2V');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Papers</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Home <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../.." class="dropdown-item">Index</a>
</li>
                                    
<li>
    <a href="../../about/about/" class="dropdown-item">Author</a>
</li>
                                    
<li>
    <a href="../../about/LICENSE/" class="dropdown-item">License</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">PLM <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../about-plm/" class="dropdown-item">PLM and graph data</a>
</li>
                                    
<li>
    <a href="../conf-mgt/" class="dropdown-item">Configuration management of industrial products in PDM/PLM</a>
</li>
                                    
<li>
    <a href="../spreadsheet-and-PLM/" class="dropdown-item">The four core functions showing you need a PLM</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Modeling <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../portfolio/" class="dropdown-item">A Simple Meta-Model for Portfolio Management</a>
</li>
                                    
<li>
    <a href="../archimate-intro/" class="dropdown-item">An Introduction to The Archimate Revolution</a>
</li>
                                    
<li>
    <a href="../archimate-recipes/" class="dropdown-item">Archimate Recipes</a>
</li>
                                    
<li>
    <a href="../mbse-vs-ea/" class="dropdown-item">Military frameworks, systems engineering and enterprise architecture</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Data <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../research/about-ml/" class="dropdown-item">About artificial neural networks and machine learning</a>
</li>
                                    
<li>
    <a href="../about-rest/" class="dropdown-item">Considerations About Rest And Web Services</a>
</li>
                                    
<li>
    <a href="../graphql-web-services/" class="dropdown-item">GraphQL And Classic Web Services</a>
</li>
                                    
<li>
    <a href="../data-interop/" class="dropdown-item">The real nature of data</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">IT <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active">Legends of IT</a>
</li>
                                    
<li>
    <a href="../five-levels/" class="dropdown-item">The Five Levels of Conceptual Maturity for IT Teams</a>
</li>
                                    
<li>
    <a href="../the-v2-vortex/" class="dropdown-item">The V2 Vortex</a>
</li>
                                    
<li>
    <a href="../various-stages/" class="dropdown-item">The Various Stages of Digital Transformation</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Research <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../research/index-research/" class="dropdown-item">Index</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Graph-oriented programming</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../graph/first-article/" class="dropdown-item">First article on graph-oriented programming</a>
</li>
            
<li>
    <a href="../../graph/staf-icgt2018/" class="dropdown-item">Conference at the STAF/ICGT 2018 in Toulouse</a>
</li>
            
<li>
    <a href="../../research/graphapps/" class="dropdown-item">GraphApps project page</a>
</li>
            
<li>
    <a href="../../research/graph-oriented-pl/" class="dropdown-item">Towards a graph-oriented programming language?</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Semantic Web</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../research/data-mig/" class="dropdown-item">Aerospace data migration</a>
</li>
            
<li>
    <a href="../../research/data-mig/" class="dropdown-item">Semantic data migration project page</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Graph transformations</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../research/graph-transfo/" class="dropdown-item">Graph transformations</a>
</li>
            
<li>
    <a href="../../research/graph-interop/" class="dropdown-item">A general interoperability model using graph transformations</a>
</li>
            
<li>
    <a href="../../research/basic-graph-transformations/" class="dropdown-item">Basic graph transformations</a>
</li>
            
<li>
    <a href="../../research/basic-semantic-graph-transformations/" class="dropdown-item">Basic semantic graph transformations</a>
</li>
            
<li>
    <a href="../../research/DSL-for-graph-topology-checks/" class="dropdown-item">DSL for graph topology check</a>
</li>
            
<li>
    <a href="../../research/graph-transformation-applicability/" class="dropdown-item">Graph transformation applicability</a>
</li>
            
<li>
    <a href="../../research/grammar-graph-transformation/" class="dropdown-item">Grammar of graph transformation</a>
</li>
            
<li>
    <a href="../../research/graph-oriented-pl/" class="dropdown-item">Graph-oriented programming language</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Various</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../research/zenon-lumiere/" class="dropdown-item">Paradoxe de Zénon et dépassement de la vitesse de la lumière</a>
</li>
            
<li>
    <a href="../../research/relativite/" class="dropdown-item">A propos de la relativité générale</a>
</li>
            
<li>
    <a href="../../research/cartan/" class="dropdown-item">Einstein, Cartan et la géométrie différentielle</a>
</li>
            
<li>
    <a href="../../research/industry-data/" class="dropdown-item">Reflections on industry data</a>
</li>
            
<li>
    <a href="../../research/rdf-design-patterns/" class="dropdown-item">UML to RDF considerations</a>
</li>
            
<li>
    <a href="../../research/resources/" class="dropdown-item">Resources</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../data-interop/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../five-levels/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#legends-of-it" class="nav-link">Legends of IT</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#what-criteria-to-judge-it-legends" class="nav-link">What criteria to judge IT legends?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#criteria-1-simplicity" class="nav-link">Criteria #1: Simplicity</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#criteria-2-as-little-dependencies-as-possible" class="nav-link">Criteria #2: As little dependencies as possible</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#criteria-3-adaptability" class="nav-link">Criteria #3: Adaptability</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#criteria-4-stick-to-standards-in-particular-in-programming-languages" class="nav-link">Criteria #4: Stick to standards, in particular in programming languages</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#criteria-5-economics-matter" class="nav-link">Criteria #5: Economics matter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#representing-a-business-domain" class="nav-link">Representing a business domain</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-1-data-are-absolute" class="nav-link">Legend #1: Data are absolute</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-2-for-a-certain-problem-there-is-only-one-code-design" class="nav-link">Legend #2: For a certain problem, there is only one code design</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-3-reusability-is-good" class="nav-link">Legend #3: Reusability is good</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-4-we-should-use-this-framework-because-everyone-uses-it" class="nav-link">Legend #4: We should use this framework because everyone uses it</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-5-we-are-in-a-digital-world-with-reliable-data" class="nav-link">Legend #5: We are in a digital world with reliable data</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-6-we-can-replace-interfaces-by-sharing-tables-in-a-database" class="nav-link">Legend #6: We can replace interfaces by sharing tables in a database</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#legend-7-we-have-great-tools-to-develop-applications" class="nav-link">Legend #7: We have great tools to develop applications</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#we-are-at-the-beginning-of-the-story-of-it" class="nav-link">We are at the beginning of the story of IT</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#annex-1-the-message-of-plm-vendors-a-legend-rooted-in-the-past" class="nav-link">Annex 1: The message of PLM vendors, a legend rooted in the past</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="legends-of-it">Legends of IT</h1>
<p><img alt="gears" src="../../images/dupondt-mirage.jpg" />
<em>(Image from</em> Les aventures de Tintin <em>by Hergé)</em></p>
<p>Information technology (IT) is a very recent engineering discipline and no one implied in IT projects should never forget this fact. Like all recent technological discipline at the heart of all modern businesses, it is both a marvelous tool, because it is "soft"-ware, a formidable enabler for business, and as it is representing lots of money, it is also a great place for legends and marketing messages.</p>
<p>As IT is a very intellectual discipline, both an engineering discipline and a creative activity, as the entry ticket of making a program run is very low, it is very easy to believe things that are untrue and to loose the global perspective of what IT is for and what are the problems it should answer to.</p>
<h2 id="what-criteria-to-judge-it-legends">What criteria to judge IT legends?</h2>
<p>The first problem we face in IT when trying to get some perspective is the problem of defining a set of criteria that will enable us to categorize the IT practices as "good" or "bad".</p>
<p>It is incredible that those criteria are not better known and shared, but after looking more carefully, it is easy to realize that there is no real consensus about those criteria. For sure, the consensus would mean that we could be able to estimate if some application is badly done. There are some books and some corporate or community practices but no real accepted consensus (except at low level coding).</p>
<p>So, we will define our own set of criteria as a kind of compass that will guide us through this journey of illusions.</p>
<h2 id="criteria-1-simplicity">Criteria #1: Simplicity</h2>
<p>Simplicity will be our first criteria. Software should be the simplest possible, software architecture also and so is IT architecture.</p>
<p>Where complexity is, failure will be, as high maintenance costs.</p>
<h2 id="criteria-2-as-little-dependencies-as-possible">Criteria #2: As little dependencies as possible</h2>
<p>Dependencies should be limited to their bare minimum because they will bring constraints on our applications.</p>
<p>In particular, reusability of external components creates dependencies that jeopardize the value of the application and its capacity to evolve freely.</p>
<p>Are we writing valuable programs with added-value for the business or are we developing plugins for the last trendy giga-framework? The question is worth asking.</p>
<p>Software is an asset on which the business is done, so it should rely on as less other stuff as possible.</p>
<h2 id="criteria-3-adaptability">Criteria #3: Adaptability</h2>
<p>Adaptability must be understood in the sense of ease of change. Adaptability is the reverse of <em>technical debt</em>: when a technology aggravates technical debt, it should never be used.</p>
<p>The definition we take for technical debt is defined very precisely in the article <a href="../../pdf/20161026-TheGraphOrientedProgrammingParadigm-ORey-PreliminaryVersion.pdf">The graph-oriented programming paradigm</a>. Adaptability means as little couplings as possible.</p>
<p>That's why reusability of external components can be a bad idea on the long run, we'll come back on that.</p>
<h2 id="criteria-4-stick-to-standards-in-particular-in-programming-languages">Criteria #4: Stick to standards, in particular in programming languages</h2>
<p>At any cost, we should stick to the standard programming language and avoid, if we can, proprietary languages.</p>
<p>Standard languages we use should be supported by a <em>stable</em> community. This community does not have to be large, but it must be steady in time.</p>
<p>Moreover, we are safer if the language specification is opened and/or massively supported and/or standardized by ANSI, ISO or any standardization office.</p>
<p>Avoiding technologies owned by private companies or privately owned specific tools (like transpilers) should be a must: those companies have the IP of the products and we will not be able to switch to another provider if they decide to make their language/tool paying, or if they decide to stop maintaining it.</p>
<h2 id="criteria-5-economics-matter">Criteria #5: Economics matter</h2>
<p>The real cost of an adaptable application should be known, so is the cost of the maintenance phase and the constraints that will come attached to this maintenance (technology, skills).</p>
<p>The real cost of a software encompasses all the phases of the project, that's why business process analysis, functional specifications and functional testing are core skills to the success of a project and to the economical data attached to it, before go-live and afterwards.</p>
<p>Remember: Software is an asset and it deserves to be treated as we treat our buildings or factories.</p>
<h2 id="representing-a-business-domain">Representing a business domain</h2>
<p>We'll not talk about games in this article but about professional applications and technology which aim is to automate some business domain.</p>
<p>Before automating a business domain, it is necessary to realize that IT primary movement is to "represent" the business knowledge associated to it.</p>
<p>We can qualify this representation:</p>
<ul>
<li>The representation of any business is partial,</li>
<li>It is included in the semantic space of the particular business,</li>
<li>This representation is relative,</li>
<li>It is composed by 2 parts:<ul>
<li>Representing the data often with database tools,</li>
<li>Representing the business rules via programs.</li>
</ul>
</li>
</ul>
<p>So, even if this statement is obvious, creating business applications is consisting, primarily, in choosing a programming language and a database.</p>
<p>Modern programming introduced the choice of using giga-frameworks that bring a lot of constraints on the application software while pretending to solve all the common problems.</p>
<h2 id="legend-1-data-are-absolute">Legend #1: Data are absolute</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>Yes</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>For sure, this statement or belief is wrong, as we have shown in our article, <a href="../data-interop/">The real nature of data</a>: <em>data is the result of the intersection of the application use cases (viewpoint) and the business semantic space</em>.</p>
<p>In the same semantic space, change the use cases and we will get a different application and so different data models.</p>
<h2 id="legend-2-for-a-certain-problem-there-is-only-one-code-design">Legend #2: For a certain problem, there is only one code design</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>Yes</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>This legend is, first of all, correlated to the last point. Depending on the various use cases we will implement, our application design will change.</p>
<p>This last statement seems obvious but few people really realized the consequences of it.</p>
<p>Second of all, application evolutions are very difficult to anticipate, that's a fact. Generally, when the evolution demands arrive, we realize that the original design was adapted or not to the direction the application goes to.</p>
<p>Most of the time, experience shows that software engineers are very bad at predicting in what direction the application will grow. This is quite normal because to be able to forecast correctly in what direction a software will develop during years, we have to know very well the business and the trends of this particular business.</p>
<h3 id="will-design-patterns-help">Will design patterns help?</h3>
<p><img alt="Design Patterns, elements of reusable OO software" src="../../images/design-patterns.jpeg" /></p>
<p>The Gamma et al. <em>Design Patterns</em> book aggravated this feeling that there is only one code design to every problem. Despite the fact that the patterns are presented like theorems, with applicability conditions that must absolutely be respected (or we create a <a href="https://en.wikipedia.org/wiki/Design_smell">design smell</a>), their industrial use results most of time in aggravating the software technical debt. Why?</p>
<p>We can propose a simple explanation: because software engineers are bad at anticipating the future of their software, because they are no business experts. So, when they choose a pattern, even if this pattern seems relevant at the moment of choice, it is a bet on the future. And this bet is often wrong.</p>
<p>A wrong design pattern brings complexity (inverse of simplicity) and increased technical debt, sometimes in huge proportions (and this is the reverse of adaptability).</p>
<p>So we must be very careful about design patterns, because they may damage a lot our code.</p>
<h3 id="the-consequences-of-having-different-designs-answering-to-the-same-problem">The consequences of having different designs answering to the same problem</h3>
<p>The fact is there are many ways to represent the same reality. In order to be convinced of that, consider the code written in IT school by students facing the same requirements. We will get one different software per person with one different design per designer.</p>
<p>The consequences of this relativity is that when the application evolves and the design principles are not documented, generations of maintainers will add up code layers corresponding to their vision of the problem.</p>
<p>As reverse engineering is long and hard, it will be easier to pile up new code doing approximately what the old one was doing with the new requirement.</p>
<p>Look at SAP legacy platforms: Quite often, hundreds of specific programs were written and are not used anymore. Why? Because the author left and the successor piled up his own vision of the evolution.</p>
<p>It is obvious to say that design documentation is required, even if that is what software company do. We can't seriously maintain a product on the long run without having a reliable map of how it is built.</p>
<p>It is also obvious to say that without any design diagram, we rely on the fact that the code will be self explanatory for the generations of maintainers that will maintain the software product. So we think they will reverse engineer the old code before doing their modifications. But everyone knows it is not true.</p>
<p>Because the software can always end up "working" with crappy practices, a lot of companies are interested in the short term result rather than in the long term maintainability. But if we could imagine the software like our house, we would panic.</p>
<p><img alt="" src="../../images/technical-debt.webp" /></p>
<h3 id="document-the-design-and-design-hypothesis">Document the design and design hypothesis</h3>
<p>In encountered twice problems coming from undocumented industry product (tangible ones), once in the aerospace and once in the nuclear area. All problems came after an incident that needed to be fixed. How can you fix an incident in a system that was optimized a long time ago without any documentation explaining what trade-off hypothesis were taken?</p>
<p>In both cases, the fix created a bigger incident. Why? Because fixing the problem violated a trade-off made long ago and made the industrial product go in a direction that was not chosen because it did not work. The cost of reverse engineering the design hypothesis was enormous. For software people, does that look familiar?</p>
<p>As a conclusion, taking into account the variety of ways to do things should lead us to enforce documentation of the design and design hypothesis. An personally, I can't insist more on the role of diagrams to capture the essence of some design choices.</p>
<h2 id="legend-3-reusability-is-good">Legend #3: Reusability is good</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>Yes</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>Yes</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>Yes</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Reusability is a double-edged sword and not at all a sign of good software.</p>
<h3 id="reusing-our-creations">Reusing our creations</h3>
<p>Because software are made by creative humans, software generates <em>attachment</em> in the heart of the software engineers. When we worked several hours on a large program and realize that it is useless, we should be able to delete it without any feelings. But the fact is, people get attached to the programs they did, because they did suffer doing them, and making them work.</p>
<p>There comes reusability as a way to save bad code. If the bad code is saved, we will generate more technical debt reusing it and it will generate useless complexity.</p>
<p><img alt="ANSI Common Lisp" src="../../images/ansi-common-lisp-19.jpeg" /></p>
<p>For sure, very often, when a feature seems generic, software engineers tend to make reusable code. We have to note that the first reusability movement is to create a function (!).</p>
<p>At micro level, this is for sure quite often necessary (see the bottom-up programming notion of Paul Graham in his <a href="https://paulgraham.com/acl.html">ANSI Common Lisp</a> book, or even the <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library">C++ Standard libray</a>).</p>
<p>But, when it goes to higher level of code, the danger is everywhere. Should we reuse? Should we create some reusable code?</p>
<h3 id="reusability-starts-at-3">Reusability starts at 3</h3>
<p>I remind a principle from an ancient VP Software Engineering at Amadeus, François Weissert, saying: "Reusability starts at 3".</p>
<p>When we have twice the same code, we should be very careful about the code to be really reusable. When we write 3 times the same code, we can consider creating a reusable component (meaning for others than ourselves).</p>
<h3 id="the-business-semantics-are-not-reusable">The business semantics are not reusable</h3>
<p>We have to remember that the semantic of the business itself is not "reusable" and so reusability should be dealt with a great deal of caution.</p>
<p>That may seem a stupid statement, but a lot of problems can come from not understanding it. Recently, in an application, the development team implemented a "generic reusable solution" to deal with 3 different functional use cases. That led inevitably to bugs and to bad management of the functional specifics of each use case.</p>
<p>Even if things look similar, we have to refrain ourselves from creating reusable components when there are not.</p>
<h3 id="reusing-giga-frameworks">Reusing giga-frameworks</h3>
<p>For some software companies, reusability has become a way to make us prisoners of their giga-framework, and especially of the mandatory updates that we must do if we want to keep been "supported". Consider the giga Javascript frameworks such as Angular or React. Being forced to reuse their framework will change drastically our design because we will need to adapt to the programming model they defined.</p>
<p>Are there ways to do better? What are those giga-frameworks provide that we really need? What is the real code we need to reuse? In some technical areas, that is obvious. As application developers, we don't want to recode the TLS protocol, so we reuse.</p>
<p>But in order to call an API in Javascript, do we need a giga-framework? No. Do we need some fancy components? Maybe yes, but what are the strings attached to this reusability? Will this corrupt our programming model? Do we really know what contract we are signing when we reuse a giga-framework? I don't think so.</p>
<h3 id="reusing-is-making-the-application-cheaper">Reusing is making the application cheaper</h3>
<p>Unfortunately, this is most often not the case.</p>
<p>Consider the various generations of client server in Figure 1 below.</p>
<p><img alt="Client server generations" src="../../yed/client-server-generations.png" /></p>
<p><em>Figure 1: Client-server generations</em></p>
<p>2 applications architectures are proposing a thin client architecture: the good old mainframe (case #1 in Figure 1) and the first generation of web clients (case #4). Those technologies were/are less expensive due to the fact that the application is almost completely located in the backend. In a certain way, the case #2 of heavy client is also quite economic but only works with a small number of users accessible on the LAN.</p>
<p>Expensive applications are the ones that are using both a heavy client and a server:</p>
<ul>
<li>Case #3: Applications such as <a href="https://en.wikipedia.org/wiki/Object_request_broker">ORB</a> applications. This model was not a success.</li>
<li>Case #5: The Javascript giga-frameworks.</li>
</ul>
<p>We can go to extreme cases of case #6 where we have 2 layers of application servers plus a heavy JS client.</p>
<p>We can exhibit some basic rules:</p>
<ul>
<li><em>The more places to code, the more expensive the application</em>.</li>
<li><em>The more frameworks, the more dependencies</em>.</li>
</ul>
<p>So, by order of magnitude :</p>
<table>
<thead>
<tr>
<th>Architecture</th>
<th>Nb of PL*</th>
<th>Client-side framework</th>
<th>Server-side framework</th>
<th>Cost</th>
<th>Dependency level</th>
</tr>
</thead>
<tbody>
<tr>
<td>Case #4</td>
<td>1 (2)</td>
<td>No</td>
<td>Yes</td>
<td>Cheapest</td>
<td>Low</td>
</tr>
<tr>
<td>Case #5</td>
<td>2 (1)</td>
<td>Yes</td>
<td>Yes</td>
<td>High</td>
<td>High</td>
</tr>
<tr>
<td>Case #6</td>
<td>2 (3)</td>
<td>Yes</td>
<td>Yes, 2 of them</td>
<td>Highest</td>
<td>Highest</td>
</tr>
</tbody>
</table>
<ul>
<li><em>PL = Programming Languages</em></li>
</ul>
<h3 id="conclusion-about-reusability">Conclusion about reusability</h3>
<p>Reusability is a powerful tool but also a very dangerous one. It also brings a dependency on your knowledge. By reusing, you make the choice of never knowing what really occurs underneath, but to stay on the surface of what the reusable component will show you.</p>
<h2 id="legend-4-we-should-use-this-framework-because-everyone-uses-it">Legend #4: We should use this framework because everyone uses it</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>Yes</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>Yes</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>Yes</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Who says we should? Our IT service provider because they have trained people and they want to amortize the trainings of their employees? The framework provider to lock us up?</p>
<p>What are the consequences of such a choice?</p>
<ul>
<li>How often the framework provider delivers big updates?</li>
<li>How often are we bound to migrate?</li>
<li>If we do not migrate to the last framework versions, what risks are we taking?<ul>
<li>Did we consider securing the code of the framework in case we don't want to migrate?</li>
<li>Did we consider securing the documentation?</li>
</ul>
</li>
<li>If we have skilled software engineers in the technology, can they adapt easily to the framework? Now? In 5 years?</li>
<li>Is it easy to get rid of the framework or are we bound to rewrite everything?</li>
</ul>
<p>We won't cite too many samples but we have, in the recent history of IT, so many examples of bad technology that "we should use because everyone uses it".</p>
<p><a href="https://en.wikipedia.org/wiki/Google_Web_Toolkit">GWT</a> is the canonical example of a Google marketing non-industrial project, so are the first versions of Angular. I wish the software companies use their own crappy software in production before providing them to the community. Look at Angular: it is not used by Google on Google Workspace. Ask them why. Maybe because Angular is a marketing project that does not respect backward compatibility and is not reliable enough, or too complicated, or too unstable to be in production at Google's? So why would that framework be good for our company?</p>
<p>Be reassured, Google is not the only one to propose marvelous magic tools which happen to be very bad choices on the long run, React from Facebook is the same kind of software components. Some design ideas are very interesting but we often use just a small part of those giga-frameworks.</p>
<p>Front-end development is the place of all "innovations", so also the place where the "economics matter" principle is the most at stake. If our team code in HTML, Javascript and CSS, our code may still run and be maintainable in 10 years, whereas in 3 years, no one will still use the giga-framework that we choose now. And between the moment of our choice and the go-live, we will be late at least 2 major versions.</p>
<p>We can wonder who really needs those giga-frameworks, maybe some marketing companies for which rewriting the full front every 2 years is OK. If we are an institution, we can do a lot in plain JS with a few simple components (easily replaceable). If we are developing an application for our company, most of the time, we mainly need forms and tables so we can stick to simple maintainable stuff (some companies may need more).</p>
<p>For backend developments, we should choose standard programming languages. This choice is complicated nowadays, because Java is not free anymore (as it was feared in the 2000's), and C# is Microsoft IP (even if it runs under Linux). That makes server side Python, JS or even PHP more appealing, even if the programming model is not the same.</p>
<p>Let's say, our choice should never be driven by your supplier or by the IT marketing messages. We will have sufficient problems to maintain our own code, we should not reuse components and frameworks when we can avoid it. It violates the whole 5 criteria.</p>
<h2 id="legend-5-we-are-in-a-digital-world-with-reliable-data">Legend #5: We are in a digital world with reliable data</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Depending on the business domains, the data are more or less reliable.</p>
<p>When they are, we can build interfaces between systems that will exchange structured data, each of them sharing the same view of the grammar of the data (see case #1 in Figure 2 below). When the traffic is slow, when systems may have trouble interoperating or when the traffic is asynchronous, files containing structured data can be exchanged (see case #2 in Figure 2 below).</p>
<p>Take the referential data, for instance the list of customers of a retail company, the list of enterprises upon which collect social taxes, the list of parts mounted on an aircraft, all that data should be reliable but, quite often, they are not.</p>
<p>There are many reasons for that:</p>
<ul>
<li>The data life cycle is short and things change quickly,</li>
<li>The number of data in the referential is very big so, even a small percentage of errors, represents a potential large problem,</li>
<li>The global process of management of those data is based partially under spreadsheets,</li>
<li>Several actors share responsibilities in a global inconsistent process with no reliable interfaces between systems (or between spreadsheets),</li>
<li>Where there should exist only one referential, there are multiple inconsistent referential systems with a difficulty of knowing what is the correct data,</li>
<li>Etc.</li>
</ul>
<p>We have to face it: the world is not perfect, and so are the data.</p>
<h3 id="denial-or-acceptation">Denial or acceptation</h3>
<p>To face such a reality, two strategies can be chosen:</p>
<ul>
<li>Denial, which leads to build software that expect data to be complete, consistent and perfect;</li>
<li>Acceptation, which leads to more or less complex ways to protect the application.</li>
</ul>
<p>Denial leads to applications that are never working properly because they expect correct data.</p>
<p>That can be solved by people correcting the data on the long run, or by opening special rights inside the application, which can put at stake its security and integrity.</p>
<p>Quite often, the application is realized to be consistent, but, facing the reality of impossibility of use because of rotten data, the application controls are released to make it usable which creates an explosion of maintenance costs and does not solve really the data quality problems.</p>
<p>Acceptation has a cost that must be integrated into the cost of the application, both at build time and at maintenance time.</p>
<h3 id="the-facade-pattern">The "façade" pattern</h3>
<p>One common solution consequence of accepting bad data as a requirement, is consisting in using the façade pattern: Instead of loading data inside our application, we are loading data into a "façade" that will be in charge of cleaning/disambiguating/complementing the data before the output is loaded into the application.</p>
<p>Note: Façade is originally a design pattern that appears primarily in the Gamma et al. But the concept is interesting in IT architecture.</p>
<p><img alt="Various kinds of façade" src="../../yed/app-facade.png" />
<em>Figure 2: Various kinds of façades</em></p>
<p>The simplest case of façade is the case #3: the façade is a set of programs that which transforms <code>data1</code> and <code>data2</code> into <code>data</code> that can be loaded safely inside the target application.</p>
<p>Depending on the gravity of data inconsistency, the façade could be a small application with its own database, its own data processing chain, able potentially to calculate and store data versions and deltas between versions and to apply complex business rules to chose the right data to be imported inside the application (case #4).</p>
<p>For sure, if the flow of data is continuous, the façade must be monitored and tuned with the right rules, in order to sustain the flow and be able to feed the application with correct and reliable data.</p>
<h3 id="never-mix-concerns">Never mix concerns</h3>
<p>In all cases, the data cleanup should never pollute the application itself and so, be segregated from it. The façade must be a separate component, a separate database if needed, and separate software. Because the application has a job to do and its design should be done considering it, the data cleanup must be done up-front.</p>
<p>The consequence of denial is to mix the 2 kinds of features inside the same application (business functionality and data cleansing), and that's why this solution ends up inevitably in bad software and bad data.</p>
<h2 id="legend-6-we-can-replace-interfaces-by-sharing-tables-in-a-database">Legend #6: We can replace interfaces by sharing tables in a database</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>Yes</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>Yes</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Each application is answering to a set of use cases, and the application data are the result of the intersection between the list of use cases with the business semantic space (see <a href="../data-interop/">The real nature of data</a>).</p>
<p>That means that each application deserves a data model fit to its needs, so different the one from the other. For sure, applications may share data, but their sharing must remains as minimal as possible and bear the less structure as possible.</p>
<p><img alt="Data interop" src="../../yed/stubs01.png" /></p>
<p><em>Figure 3: Data models are adapted to each application</em></p>
<p>In Figure 3, we can see how 3 different data representations are semantically equivalent but absolutely not technically equivalent. We'll note that the exchange format is the most "loose" format. That enables each stakeholder in the exchange to rebuild its data structures conforming to its use cases.</p>
<p>Figure 3 is showing an interface between systems. If we were to project the <code>viewpoint1</code> directly in Application 2, we would distort the data model of Application 2 imposing, as a constraint, a part of the datamodel of Application 1. Let's suppose we do that with database materialized views, we will distort and create code of Application 2 based on data structures (that can change) of Application 1.</p>
<p>This practice is very dirty and very risky because:</p>
<ul>
<li>It creates an operational complexity, Application 2 not being autonomous anymore,</li>
<li>It creates a dependency that is useless, because an interface would have transform this hard dependency into a loose dependency (at the exchange format level and not at the database level),</li>
<li>It creates a design and code distortion in the Application 2, because the <code>viewpoint1</code> is not what was imagined as a design for Application 2.</li>
</ul>
<p>The last point is quite interesting: by transforming the exchange format into <code>viewpoint2</code>, the Application 2 can do some modifications on the objects transported by the exchange format to make them its own. In other terms, the transformation can include business rules and never store A or C but A union C. Quite often, transactions between systems are triggering business rules to adapt the incoming data to the target semantic space.</p>
<p>The conclusion is, for sure, we can't replace interfaces by sharing database structures.</p>
<p>The second conclusion is: we can't group several business domains inside the same database, because one of them will drive and the others will live at the rhythm of the dominant.</p>
<p>See also the annex 1:<a href="#annexe1"> The message of PLM vendors, a legend rooted in the past</a></p>
<h2 id="legend-7-we-have-great-tools-to-develop-applications">Legend #7: We have great tools to develop applications</h2>
<table>
<thead>
<tr>
<th>#</th>
<th>Criteria</th>
<th>Applicable</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Simplicity</td>
<td>Yes</td>
</tr>
<tr>
<td>2</td>
<td>No dependencies</td>
<td>Yes</td>
</tr>
<tr>
<td>3</td>
<td>Adaptability</td>
<td>Yes</td>
</tr>
<tr>
<td>4</td>
<td>Standards</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>Economics</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>This part will introduce <a href="../../pdf/20161026-TheGraphOrientedProgrammingParadigm-ORey-PreliminaryVersion.pdf">The graph-oriented programming paradigm</a> article.</p>
<p>Even if we can realize applications in object-oriented programming and with relational databases, this technology is very bad in terms of coupling and generates, from day 1, a huge technical debt. The logical consequence is an exponential explosion of the maintenance costs with time (cost of the function point tending towards the infinite).</p>
<p>Can we stick to this set of tools and technologies that we have since almost 30 years: OOP + relational DB? Can we open our eyes on the economical heresy brought by this technology, especially in maintenance phases? Can we see our software activities differently, by taking a step back on those last decades?</p>
<p>Are we doomed to accept that a front-end must use giga-frameworks and must be rewritten every 2 years while the backend has inevitably exponential maintenance costs over 10 years?</p>
<p>Take your time to read the article, at least the explanation on why what we are doing every day is economically inefficient.</p>
<h2 id="we-are-at-the-beginning-of-the-story-of-it">We are at the beginning of the story of IT</h2>
<p>We have to realize that we are just <em>at the beginning of the history of IT</em>. Some could say that AI will enhance our capacity to write code. Yes, maybe, but AI won't find alternate programming models to enter the new phase of our IT discovery. I fear we have to do the job.</p>
<p><a href="../../pdf/20161026-TheGraphOrientedProgrammingParadigm-ORey-PreliminaryVersion.pdf">Graph-oriented programming paradigm</a> is a way forward that seems very promising, but there should be plenty of alternate ways of doing stuff.</p>
<p>I just hope AI won't prevent us to be as creative as the 70s/80s where. Instead of just following marketing-led companies, software engineers and researchers were experimenting, creating and discovering. Where are those guys, now?</p>
<p>We should identify the legends in order to cease believing in them. We must find new paths, find the real "soft" in our "ware", and target a real economical efficiency of softare development. We need those new paradigms.</p>
<p><a name="annexe1"></p>
<h2 id="annex-1-the-message-of-plm-vendors-a-legend-rooted-in-the-past">Annex 1: The message of PLM vendors, a legend rooted in the past</h2>
<h3 id="a-legend-shared-between-plm-software-companies">A legend shared between PLM software companies</h3>
<p>We will make a specific note to analyze the marketing messages coming from PLM (Product Lifecycle Management) vendors. For memory, a PLM is a complex software that manages the lifecycle of industrial products. The main characteristics of a PLM is to consider data as belonging to a temporal graph that, with time, replaces old parts by new parts in the newer products.</p>
<p>Every PLM supplier proposes products that can address (more or less) the 3 engineering "divisions" of any industrial company (divisions that are doing "design"):</p>
<ul>
<li>Engineering: designing the product,</li>
<li>Manufacturing engineering, also named Manufacturing preparation: designing the production of the product,</li>
<li>Support engineering: designing the maintenance of the industrial product.</li>
</ul>
<p>Each PLM vendor indicates that all the industrial data of the three domains can and should cohabit in the same database, whereas it is not the case, as we will show.</p>
<h3 id="the-plm-a-software-coming-from-older-collaboration-software">The PLM, a software coming from older collaboration software</h3>
<p>Maybe, it is worth reminding the history of those systems and make a little legend archaeology.</p>
<p><img alt="From EDMS to PLM" src="../../yed/steps-to-plm.png" /></p>
<p><em>Figure 4: From EDMS to PLM</em></p>
<p>At the beginning, the 3 engineering disciplines are working in paper separately and exchange physical documents (#1 in Figure 4).</p>
<p>When the first digital tools enter the industry, the documents did become office documents and 2D/3D models. Putting in place an Electronic Document Management System (EDMS, #2 in Figure 4) was a way to enable collaboration because each organization could now access to the documents of the other without paper transfer.</p>
<p>Then came the "PDM" (Part Data Management) systems: What if all documents are indexed based on the part number they are referring to? In this system, every stakeholder is able to better find the documents applicable to its parts, whatever the perspective (design , manufacturing or support). This is shown in #3 in Picture 3.</p>
<p>We can note that this evolution follows the general application evolution described in the <a href="../data-interop/">Real Nature of Data</a>.</p>
<p><img alt="Semantic space" src="../../yed/semantic-space.png" /></p>
<p><em>Figure 5: consult the <a href="../data-interop/">Real Nature of Data</a> article for more information</em></p>
<h3 id="the-plm-changes-everything">The PLM changes everything</h3>
<p>The technology advancing, the products are becoming more complex and we have to manage lots of configurations and options. All data must be put inside a database in a data model that is adapted to...</p>
<p>To what exactly the PLM data model is adapted? To Engineering requirements of course, because as they design the product, they are at the core of the system.</p>
<p>Keeping the collaboration on the PLM for actors that are not Engineering is good for every other stakeholder that will be able to benefit from structured data (understand "Engineering structured data"), which is what is represented by the case #4 on Figure 4.</p>
<p>This is where the PLM software companies are making a terrible mistake: When you enter the step of designing the activities of the semantic domain named "Engineering", the objects that you model and their lifecycle are specific to Engineering, and do not apply straight away to Manufacturing or Support.</p>
<p>For sure, you can try to "extend" the objects and the lifecycle of the support to integrate new requirements, but if you keep one single database, your core model will be designed for Engineering, with an Engineering specific model.</p>
<h3 id="3-models-for-3-semantic-businesses">3 models for 3 semantic businesses</h3>
<p>The case #5 of the Figure 4 shows the general case:</p>
<ul>
<li>You have 3 PLMs, one for each domain, perfectly adapted to the use cases, the objects, the lifecycles and the rhythms of the processes of each domain;</li>
<li>You have a delivery software in Engineering that is producing something consistent for the downstream activities, being Manufacturing engineering or Support Engineering;</li>
<li>You have potentially 2 façade applications that can be complex enough to have their own databases, make their own deltas between 2 Engineering deliveries.</li>
</ul>
<p>Sometimes, the case #4 can work if your products are simple, if the engineering is knowing 100% of the mounted parts and if the manufacturing and support is simple. But in big industries such as aerospace, the model #4 is not working.</p>
<p>The case of industry is not a particular case: You can't fit 2 or more different business semantic domains in the same database. Trying to make those semantic domains cohabit in the same instance is leading almost inevitably to one semantic domain <code>A</code> imposing its rules (rhythm, lifecycle, data model, etc.) to another semantic domain <code>B</code>. That generates downstream systems that will recreate the models and lifecycle that <code>B</code> cannot operate in a PLM dominated by <code>A</code> (often with spreadsheets, small databases, reports and manual works).</p>
<p>This also generates horrible costs and non convergence of projects, which is common in the PLM area.</p>
<p><a name="semantic-domain"></p>
<h3 id="what-are-the-business-semantic-domains">What are the business semantic domains?</h3>
<p>The real challenge becomes to identify properly those "business semantic domains" that drive the perimeter where an application can be built on a single data model.</p>
<p>To determine those semantic spaces, the knowledge of the company organization and business processes is crucial. Business processes exhibit business concepts, cardinalities between concepts, lifecycles of the various types of objects, and rhythms of the various processes.</p>
<p>The enterprise architecture description language <a href="../archimate-intro/">Archimate</a> is one of the best tools to understand where the semantic space begins and where it ends (even is sometimes, some <a href="../archimate-recipes/">recipes</a> are required).</p>
<p>Once the semantic domains are identified, we can assess their limits by analyzing the internal dependencies of intra-domain concepts and "bridges" wit extra-domain concepts (see the <a href="../../pdf/20161026-TheGraphOrientedProgrammingParadigm-ORey-PreliminaryVersion.pdf">Graph-oriented programming paradigm</a> for more information).</p>
<h3 id="a-legend-grounded-in-past-software">A legend grounded in past software</h3>
<p>PLM vendors, intoxicated by their historical "collaboration"-based marketing message, did not realize that making a real application with structured data was specializing the product to a certain set of use cases, and so to a particular business.</p>
<p>They end up selling "mega-monoliths" without realizing that this message is contradictory to the IT architecture trends everywhere else, apart from industry.</p>
<p><em>(July 20 2024)</em></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyleft Olivier Rey 2017-2024 - Site licensed under the GNU FDL V3</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
